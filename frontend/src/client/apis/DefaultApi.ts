// tslint:disable
/**
 * Macro Macro API
 * An API that provides access to recipe and ingredient information, both user-generated and sourced from the USDA
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    NamedMacros,
    NamedMacrosFromJSON,
    NamedMacrosToJSON,
    NewIngredient,
    NewIngredientFromJSON,
    NewIngredientToJSON,
    NewRecipe,
    NewRecipeFromJSON,
    NewRecipeToJSON,
    Recipe,
    RecipeFromJSON,
    RecipeToJSON,
} from '../models';

export interface CreateIngredientRequest {
    newIngredient: NewIngredient;
}

export interface CreateRecipeRequest {
    newRecipe: NewRecipe;
}

export interface FindIngredientByUIDRequest {
    uid: string;
}

export interface FindIngredientsRequest {
    sort?: string;
    limit?: number;
}

export interface FindRecipeByUIDRequest {
    uid: string;
    format?: string;
}

export interface FindRecipesRequest {
    sort?: string;
    limit?: number;
}

export interface SearchByNameRequest {
    q: string;
    sort?: string;
    limit?: number;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Creates a new ingredient.  Duplicates are allowed.
     */
    async createIngredientRaw(requestParameters: CreateIngredientRequest): Promise<runtime.ApiResponse<NamedMacros>> {
        if (requestParameters.newIngredient === null || requestParameters.newIngredient === undefined) {
            throw new runtime.RequiredError('newIngredient','Required parameter requestParameters.newIngredient was null or undefined when calling createIngredient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ingredients`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewIngredientToJSON(requestParameters.newIngredient),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedMacrosFromJSON(jsonValue));
    }

   /**
    * Creates a new ingredient.  Duplicates are allowed.
    */
    async createIngredient(requestParameters: CreateIngredientRequest): Promise<NamedMacros> {
        const response = await this.createIngredientRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new recipe.  Duplicates are allowed.
     */
    async createRecipeRaw(requestParameters: CreateRecipeRequest): Promise<runtime.ApiResponse<NamedMacros>> {
        if (requestParameters.newRecipe === null || requestParameters.newRecipe === undefined) {
            throw new runtime.RequiredError('newRecipe','Required parameter requestParameters.newRecipe was null or undefined when calling createRecipe.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/recipes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewRecipeToJSON(requestParameters.newRecipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedMacrosFromJSON(jsonValue));
    }

   /**
    * Creates a new recipe.  Duplicates are allowed.
    */
    async createRecipe(requestParameters: CreateRecipeRequest): Promise<NamedMacros> {
        const response = await this.createRecipeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the ingredient specified by the UID
     */
    async findIngredientByUIDRaw(requestParameters: FindIngredientByUIDRequest): Promise<runtime.ApiResponse<NamedMacros>> {
        if (requestParameters.uid === null || requestParameters.uid === undefined) {
            throw new runtime.RequiredError('uid','Required parameter requestParameters.uid was null or undefined when calling findIngredientByUID.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingredients/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters.uid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedMacrosFromJSON(jsonValue));
    }

   /**
    * Returns the ingredient specified by the UID
    */
    async findIngredientByUID(requestParameters: FindIngredientByUIDRequest): Promise<NamedMacros> {
        const response = await this.findIngredientByUIDRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns all ingredients the user has saved 
     */
    async findIngredientsRaw(requestParameters: FindIngredientsRequest): Promise<runtime.ApiResponse<Array<NamedMacros>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingredients`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NamedMacrosFromJSON));
    }

   /**
    * Returns all ingredients the user has saved 
    */
    async findIngredients(requestParameters: FindIngredientsRequest): Promise<Array<NamedMacros>> {
        const response = await this.findIngredientsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the recipe specified by the UID
     */
    async findRecipeByUIDRaw(requestParameters: FindRecipeByUIDRequest): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters.uid === null || requestParameters.uid === undefined) {
            throw new runtime.RequiredError('uid','Required parameter requestParameters.uid was null or undefined when calling findRecipeByUID.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/recipes/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters.uid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

   /**
    * Returns the recipe specified by the UID
    */
    async findRecipeByUID(requestParameters: FindRecipeByUIDRequest): Promise<Recipe> {
        const response = await this.findRecipeByUIDRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns all recipes the user has saved
     */
    async findRecipesRaw(requestParameters: FindRecipesRequest): Promise<runtime.ApiResponse<Array<NamedMacros>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/recipes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NamedMacrosFromJSON));
    }

   /**
    * Returns all recipes the user has saved
    */
    async findRecipes(requestParameters: FindRecipesRequest): Promise<Array<NamedMacros>> {
        const response = await this.findRecipesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Search for ingredients and recipes by name
     */
    async searchByNameRaw(requestParameters: SearchByNameRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        if (requestParameters.q === null || requestParameters.q === undefined) {
            throw new runtime.RequiredError('q','Required parameter requestParameters.q was null or undefined when calling searchByName.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

   /**
    * Search for ingredients and recipes by name
    */
    async searchByName(requestParameters: SearchByNameRequest): Promise<InlineResponse200> {
        const response = await this.searchByNameRaw(requestParameters);
        return await response.value();
    }

}
